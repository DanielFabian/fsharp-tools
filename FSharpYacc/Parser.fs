/// Implementation file for parser generated by the fsyacc-compatibility backend for fsharpyacc.
module internal FSharpYacc.Parser

#nowarn "64" // turn off warnings that type variables used in production annotations are instantiated to concrete type

open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text.Parsing.ParseHelpers

(*

Copyright 2005-2008 Microsoft Corporation
Copyright 2012-2013 Jack Pappas

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*)

open Graham.Grammar
open FSharpYacc.Ast

// Turn off ML-compatibility-only warnings.
#nowarn "62"


// This type is the type of tokens accepted by the parser
type token =
  | TOKEN of string option
  | TYPE of string
  | BAR
  | PERCENT_PERCENT
  | START
  | LEFT
  | RIGHT
  | NONASSOC
  | LESS
  | GREATER
  | COLON
  | PREC
  | SEMI
  | EOF
  | ERROR
  | HEADER of CodeFragment option
  | CODE of CodeFragment option
  | IDENT of string

// This type is used to give symbolic names to token indexes, useful for error messages
type private tokenId =
    | TOKEN_TOKEN
    | TOKEN_TYPE
    | TOKEN_BAR
    | TOKEN_PERCENT_PERCENT
    | TOKEN_START
    | TOKEN_LEFT
    | TOKEN_RIGHT
    | TOKEN_NONASSOC
    | TOKEN_LESS
    | TOKEN_GREATER
    | TOKEN_COLON
    | TOKEN_PREC
    | TOKEN_SEMI
    | TOKEN_EOF
    | TOKEN_ERROR
    | TOKEN_HEADER
    | TOKEN_CODE
    | TOKEN_IDENT
    | TOKEN_end_of_input
    | TOKEN_error

// This type is used to give symbolic names to token indexes, useful for error messages
type private nonTerminalId =
    | NONTERM__startspec
    | NONTERM_spec
    | NONTERM_headeropt
    | NONTERM_decls
    | NONTERM_decl
    | NONTERM_idents
    | NONTERM_rules
    | NONTERM_rule
    | NONTERM_optbar
    | NONTERM_optsemi
    | NONTERM_clauses
    | NONTERM_clause
    | NONTERM_syms
    | NONTERM_optprec

// This function maps tokens to integers indexes
let private tagOfToken = function
    | TOKEN _ -> 0
    | TYPE _ -> 1
    | BAR -> 2
    | PERCENT_PERCENT -> 3
    | START -> 4
    | LEFT -> 5
    | RIGHT -> 6
    | NONASSOC -> 7
    | LESS -> 8
    | GREATER -> 9
    | COLON -> 10
    | PREC -> 11
    | SEMI -> 12
    | EOF -> 13
    | ERROR -> 14
    | HEADER _ -> 15
    | CODE _ -> 16
    | IDENT _ -> 17

/// Maps integers indexes to symbolic token ids.
let private tokenTagToTokenId (tokenIdx : int) =
    match tokenIdx with
    | 0 -> TOKEN_TOKEN
    | 1 -> TOKEN_TYPE
    | 2 -> TOKEN_BAR
    | 3 -> TOKEN_PERCENT_PERCENT
    | 4 -> TOKEN_START
    | 5 -> TOKEN_LEFT
    | 6 -> TOKEN_RIGHT
    | 7 -> TOKEN_NONASSOC
    | 8 -> TOKEN_LESS
    | 9 -> TOKEN_GREATER
    | 10 -> TOKEN_COLON
    | 11 -> TOKEN_PREC
    | 12 -> TOKEN_SEMI
    | 13 -> TOKEN_EOF
    | 14 -> TOKEN_ERROR
    | 15 -> TOKEN_HEADER
    | 16 -> TOKEN_CODE
    | 17 -> TOKEN_IDENT
    | 20 -> TOKEN_end_of_input
    | 18 -> TOKEN_error
    | _ -> failwith "tokenTagToTokenId: bad token"

/// Maps production indexes returned in syntax errors to strings representing
/// the non-terminal that would be produced by that production.
let private prodIdxToNonTerminal (prodIdx : int) =
    match prodIdx with
    | 0 -> NONTERM__startspec
    | 1 -> NONTERM_spec
    | 2 -> NONTERM_headeropt
    | 3 -> NONTERM_headeropt
    | 4 -> NONTERM_decls
    | 5 -> NONTERM_decls
    | 6 -> NONTERM_decl
    | 7 -> NONTERM_decl
    | 8 -> NONTERM_decl
    | 9 -> NONTERM_decl
    | 10 -> NONTERM_decl
    | 11 -> NONTERM_decl
    | 12 -> NONTERM_idents
    | 13 -> NONTERM_idents
    | 14 -> NONTERM_rules
    | 15 -> NONTERM_rules
    | 16 -> NONTERM_rule
    | 17 -> NONTERM_optbar
    | 18 -> NONTERM_optbar
    | 19 -> NONTERM_optsemi
    | 20 -> NONTERM_optsemi
    | 21 -> NONTERM_clauses
    | 22 -> NONTERM_clauses
    | 23 -> NONTERM_clause
    | 24 -> NONTERM_syms
    | 25 -> NONTERM_syms
    | 26 -> NONTERM_syms
    | 27 -> NONTERM_optprec
    | 28 -> NONTERM_optprec
    | _ -> failwith "prodIdxToNonTerminal: bad production index"

let [<Literal>] private _fsyacc_endOfInputTag = 20
let [<Literal>] private _fsyacc_tagOfErrorTerminal = 18

/// Gets the name of a token as a string.
let token_to_string (t : token) =
    match t with
    | TOKEN _ -> "TOKEN"
    | TYPE _ -> "TYPE"
    | BAR -> "BAR"
    | PERCENT_PERCENT -> "PERCENT_PERCENT"
    | START -> "START"
    | LEFT -> "LEFT"
    | RIGHT -> "RIGHT"
    | NONASSOC -> "NONASSOC"
    | LESS -> "LESS"
    | GREATER -> "GREATER"
    | COLON -> "COLON"
    | PREC -> "PREC"
    | SEMI -> "SEMI"
    | EOF -> "EOF"
    | ERROR -> "ERROR"
    | HEADER _ -> "HEADER"
    | CODE _ -> "CODE"
    | IDENT _ -> "IDENT"

/// Gets the data carried by a token as an object.
let private _fsyacc_dataOfToken (t : token) =
    match t with
    | TOKEN _fsyacc_x -> box _fsyacc_x
    | TYPE _fsyacc_x -> box _fsyacc_x
    | BAR -> (null : System.Object)
    | PERCENT_PERCENT  -> (null : System.Object)
    | START -> (null : System.Object)
    | LEFT -> (null : System.Object)
    | RIGHT -> (null : System.Object)
    | NONASSOC -> (null : System.Object)
    | LESS -> (null : System.Object)
    | GREATER -> (null : System.Object)
    | COLON -> (null : System.Object)
    | PREC -> (null : System.Object)
    | SEMI -> (null : System.Object)
    | EOF -> (null : System.Object)
    | ERROR -> (null : System.Object)
    | HEADER _fsyacc_x -> box _fsyacc_x
    | CODE _fsyacc_x -> box _fsyacc_x
    | IDENT _fsyacc_x -> box _fsyacc_x

let private _fsyacc_gotos = [| 0us; 65535us; 1us; 65535us; 0us; 1us; 1us; 65535us; 0us; 2us; 2us; 65535us; 2us; 3us; 7us; 8us; 2us; 65535us; 2us; 7us; 7us; 7us; 7us; 65535us; 9us; 10us; 11us; 12us; 13us; 14us; 15us; 16us; 17us; 18us; 19us; 20us; 21us; 22us; 2us; 65535us; 4us; 5us; 23us; 24us; 2us; 65535us; 4us; 23us; 23us; 23us; 1us; 65535us; 26us; 27us; 1us; 65535us; 28us; 29us; 2us; 65535us; 27us; 28us; 33us; 34us; 2us; 65535us; 27us; 32us; 33us; 32us; 4us; 65535us; 27us; 35us; 33us; 35us; 38us; 39us; 40us; 41us; 1us; 65535us; 35us; 36us; |]
let private _fsyacc_sparseGotoTableRowOffsets = [|0us; 1us; 3us; 5us; 8us; 11us; 19us; 22us; 25us; 27us; 29us; 32us; 35us; 40us; |]
let private _fsyacc_stateToProdIdxsTableElements = [| 1us; 0us; 1us; 0us; 1us; 1us; 1us; 1us; 1us; 1us; 1us; 1us; 1us; 2us; 1us; 5us; 1us; 5us; 1us; 6us; 1us; 6us; 1us; 7us; 1us; 7us; 1us; 8us; 1us; 8us; 1us; 9us; 1us; 9us; 1us; 10us; 1us; 10us; 1us; 11us; 1us; 11us; 1us; 12us; 1us; 12us; 2us; 14us; 15us; 1us; 14us; 1us; 16us; 1us; 16us; 1us; 16us; 1us; 16us; 1us; 16us; 1us; 18us; 1us; 20us; 2us; 21us; 22us; 1us; 21us; 1us; 21us; 1us; 23us; 1us; 23us; 1us; 23us; 1us; 24us; 1us; 24us; 1us; 25us; 1us; 25us; 1us; 28us; 1us; 28us; |]
let private _fsyacc_stateToProdIdxsTableRowOffsets = [|0us; 2us; 4us; 6us; 8us; 10us; 12us; 14us; 16us; 18us; 20us; 22us; 24us; 26us; 28us; 30us; 32us; 34us; 36us; 38us; 40us; 42us; 44us; 46us; 49us; 51us; 53us; 55us; 57us; 59us; 61us; 63us; 65us; 68us; 70us; 72us; 74us; 76us; 78us; 80us; 82us; 84us; 86us; 88us; |]
let [<Literal>] private _fsyacc_action_rows = 44
let private _fsyacc_actionTableElements = [|1us; 16387us; 15us; 6us; 0us; 49152us; 6us; 16388us; 0us; 9us; 1us; 11us; 4us; 13us; 5us; 15us; 6us; 17us; 7us; 19us; 1us; 32768us; 3us; 4us; 1us; 32768us; 17us; 25us; 0us; 16385us; 0us; 16386us; 6us; 16388us; 0us; 9us; 1us; 11us; 4us; 13us; 5us; 15us; 6us; 17us; 7us; 19us; 0us; 16389us; 1us; 16397us; 17us; 21us; 0us; 16390us; 1us; 16397us; 17us; 21us; 0us; 16391us; 1us; 16397us; 17us; 21us; 0us; 16392us; 1us; 16397us; 17us; 21us; 0us; 16393us; 1us; 16397us; 17us; 21us; 0us; 16394us; 1us; 16397us; 17us; 21us; 0us; 16395us; 1us; 16397us; 17us; 21us; 0us; 16396us; 1us; 16399us; 17us; 25us; 0us; 16398us; 1us; 32768us; 10us; 26us; 1us; 16401us; 2us; 30us; 2us; 16410us; 14us; 40us; 17us; 38us; 1us; 16403us; 12us; 31us; 0us; 16400us; 0us; 16402us; 0us; 16404us; 1us; 16406us; 2us; 33us; 2us; 16410us; 14us; 40us; 17us; 38us; 0us; 16405us; 1us; 16411us; 11us; 42us; 1us; 32768us; 16us; 37us; 0us; 16407us; 2us; 16410us; 14us; 40us; 17us; 38us; 0us; 16408us; 2us; 16410us; 14us; 40us; 17us; 38us; 0us; 16409us; 1us; 32768us; 17us; 43us; 0us; 16412us; |]
let private _fsyacc_actionTableRowOffsets = [|0us; 2us; 3us; 10us; 12us; 14us; 15us; 16us; 23us; 24us; 26us; 27us; 29us; 30us; 32us; 33us; 35us; 36us; 38us; 39us; 41us; 42us; 44us; 45us; 47us; 48us; 50us; 52us; 55us; 57us; 58us; 59us; 60us; 62us; 65us; 66us; 68us; 70us; 71us; 74us; 75us; 78us; 79us; 81us; |]
let private _fsyacc_reductionSymbolCounts = [|1us; 4us; 1us; 0us; 0us; 2us; 2us; 2us; 2us; 2us; 2us; 2us; 2us; 0us; 2us; 1us; 5us; 0us; 1us; 0us; 1us; 3us; 1us; 3us; 2us; 2us; 0us; 0us; 2us; |]
let private _fsyacc_productionToNonTerminalTable = [|0us; 1us; 2us; 2us; 3us; 3us; 4us; 4us; 4us; 4us; 4us; 4us; 5us; 5us; 6us; 6us; 7us; 8us; 8us; 9us; 9us; 10us; 10us; 11us; 12us; 12us; 12us; 13us; 13us; |]
let private _fsyacc_immediateActions = [|65535us; 49152us; 65535us; 65535us; 65535us; 16385us; 16386us; 65535us; 16389us; 65535us; 16390us; 65535us; 16391us; 65535us; 16392us; 65535us; 16393us; 65535us; 16394us; 65535us; 16395us; 65535us; 16396us; 65535us; 16398us; 65535us; 65535us; 65535us; 65535us; 16400us; 16402us; 16404us; 65535us; 65535us; 16405us; 65535us; 65535us; 16407us; 65535us; 16408us; 65535us; 16409us; 65535us; 16412us; |]

let _fsyacc_reductions ()  =    [|
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : Specification)) in
            box
                (
                   (
                      raise (Microsoft.FSharp.Text.Parsing.Accept(box _1))
                   )
                 : '_startspec));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : 'headeropt)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'decls)) in
            let _4 = (let data = parseState.GetInput(4) in (unbox data : 'rules)) in
            box
                (
                   (
                      List.foldBack (fun f x -> f x) _2 {
                        Header = _1;
                        Footer = None;
                        NonterminalDeclarations = List.empty;
                        TerminalDeclarations = List.empty;
                        StartingProductions = List.empty;
                        Associativities = List.empty;
                        Productions = _4; }
                   )
                 : Specification));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : CodeFragment option)) in
            box
                (
                   (
                      _1
                   )
                 : 'headeropt));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      //"", (parseState.ResultRange |> fst)
                      None
                   )
                 : 'headeropt));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      [] 
                   )
                 : 'decls));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : 'decl)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'decls)) in
            box
                (
                   (
                      _1 :: _2 
                   )
                 : 'decls));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : DeclaredType option)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'idents)) in
            box
                (
                   (
                      (fun x -> { x with TerminalDeclarations = x.TerminalDeclarations @ [(_1, _2)] })
                   )
                 : 'decl));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : DeclaredType)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'idents)) in
            box
                (
                   (
                      (fun x -> {x with NonterminalDeclarations = x.NonterminalDeclarations @ (_2 |> List.map (fun x -> _1, x)); } )
                     
                   )
                 : 'decl));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'idents)) in
            box
                (
                   (
                      (fun x -> {x with StartingProductions = x.StartingProductions @ _2} ) 
                   )
                 : 'decl));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'idents)) in
            box
                (
                   (
                      (fun x -> {x with Associativities = x.Associativities @ [(Associativity.Left, _2)]} ) 
                   )
                 : 'decl));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'idents)) in
            box
                (
                   (
                      (fun x -> {x with Associativities = x.Associativities @ [(Associativity.Right, _2)]} ) 
                   )
                 : 'decl));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'idents)) in
            box
                (
                   (
                      (fun x -> {x with Associativities = x.Associativities @ [(Associativity.NonAssociative, _2)]} ) 
                   )
                 : 'decl));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : string)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'idents)) in
            box
                (
                   (
                      _1 :: _2 
                   )
                 : 'idents));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      [] 
                   )
                 : 'idents));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : 'rule)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'rules)) in
            box
                (
                   (
                      _1 :: _2 
                   )
                 : 'rules));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : 'rule)) in
            box
                (
                   (
                      [_1] 
                   )
                 : 'rules));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : string)) in
            let _3 = (let data = parseState.GetInput(3) in (unbox data : 'optbar)) in
            let _4 = (let data = parseState.GetInput(4) in (unbox data : 'clauses)) in
            let _5 = (let data = parseState.GetInput(5) in (unbox data : 'optsemi)) in
            box
                (
                   (
                      (_1,_4) 
                   )
                 : 'rule));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      
                   )
                 : 'optbar));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      
                   )
                 : 'optbar));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      
                   )
                 : 'optsemi));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      
                   )
                 : 'optsemi));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : 'clause)) in
            let _3 = (let data = parseState.GetInput(3) in (unbox data : 'clauses)) in
            box
                (
                   (
                     _1 :: _3 
                   )
                 : 'clauses));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : 'clause)) in
            box
                (
                   (
                      [_1] 
                   )
                 : 'clauses));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : 'syms)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'optprec)) in
            let _3 = (let data = parseState.GetInput(3) in (unbox data : CodeFragment option)) in
            box
                (
                   (
                      // Rule
                      { Symbols = _1;
                        Action = _3;
                        ImpersonatedPrecedence = _2; }
                   )
                 : 'clause));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (unbox data : string)) in
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'syms)) in
            box
                (
                   (
                      _1 :: _2 
                   )
                 : 'syms));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _2 = (let data = parseState.GetInput(2) in (unbox data : 'syms)) in
            box
                (
                   (
                      "error" :: _2 
                   )
                 : 'syms));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      [] 
                   )
                 : 'syms));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            box
                (
                   (
                      None 
                   )
                 : 'optprec));
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _2 = (let data = parseState.GetInput(2) in (unbox data : string)) in
            box
                (
                   (
                      Some _2 
                   )
                 : 'optprec));
|]

let tables () : Microsoft.FSharp.Text.Parsing.Tables<_> = 
  { reductions= _fsyacc_reductions ();
    endOfInputTag = _fsyacc_endOfInputTag;
    tagOfToken = tagOfToken;
    dataOfToken = _fsyacc_dataOfToken; 
    actionTableElements = _fsyacc_actionTableElements;
    actionTableRowOffsets = _fsyacc_actionTableRowOffsets;
    stateToProdIdxsTableElements = _fsyacc_stateToProdIdxsTableElements;
    stateToProdIdxsTableRowOffsets = _fsyacc_stateToProdIdxsTableRowOffsets;
    reductionSymbolCounts = _fsyacc_reductionSymbolCounts;
    immediateActions = _fsyacc_immediateActions;
    gotos = _fsyacc_gotos;
    sparseGotoTableRowOffsets = _fsyacc_sparseGotoTableRowOffsets;
    tagOfErrorTerminal = _fsyacc_tagOfErrorTerminal;
    parseError = (fun (ctxt:Microsoft.FSharp.Text.Parsing.ParseErrorContext<_>) -> 
                              match parse_error_rich with 
                              | Some f -> f ctxt
                              | None -> parse_error ctxt.Message);
    numTerminals = 21;
    productionToNonTerminalTable = _fsyacc_productionToNonTerminalTable  }
let engine lexer lexbuf startState = (tables ()).Interpret(lexer, lexbuf, startState)
let spec lexer lexbuf : Specification =
    unbox ((tables ()).Interpret(lexer, lexbuf, 0))

