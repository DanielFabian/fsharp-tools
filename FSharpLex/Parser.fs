/// Implementation file for parser generated by the fsyacc-compatibility backend for fsharpyacc.
module internal FSharpLex.Parser

#nowarn "64" // turn off warnings that type variables used in production annotations are instantiated to concrete type

open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text.Parsing.ParseHelpers

(*

Copyright 2005-2008 Microsoft Corporation
Copyright 2012-2013 Jack Pappas

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*)

open FSharpLex.SpecializedCollections
open FSharpLex
open FSharpLex.Ast



// This type is the type of tokens accepted by the parser
type token =
    | AND
    | BAR
    | CHAR of (char)
    | CODE of (CodeFragment)
    | DASH
    | DOT
    | EOF
    | EQUALS
    | HAT
    | IDENT of (string)
    | LBRACK
    | LET
    | LPAREN
    | PARSE
    | PLUS
    | QMARK
    | RBRACK
    | RPAREN
    | RULE
    | STAR
    | STRING of (string)
    | UNDERSCORE
    | UNICODE_CATEGORY of (string)

/// This type is used to give symbolic names to token indexes, useful for error messages.
type private tokenId =
    | TOKEN_AND
    | TOKEN_BAR
    | TOKEN_CHAR
    | TOKEN_CODE
    | TOKEN_DASH
    | TOKEN_DOT
    | TOKEN_EOF
    | TOKEN_EQUALS
    | TOKEN_HAT
    | TOKEN_IDENT
    | TOKEN_LBRACK
    | TOKEN_LET
    | TOKEN_LPAREN
    | TOKEN_PARSE
    | TOKEN_PLUS
    | TOKEN_QMARK
    | TOKEN_RBRACK
    | TOKEN_RPAREN
    | TOKEN_RULE
    | TOKEN_STAR
    | TOKEN_STRING
    | TOKEN_UNDERSCORE
    | TOKEN_UNICODE_CATEGORY
    | TOKEN_end_of_input
    | TOKEN_error

/// This type is used to give symbolic names to token indexes, useful for error messages.
type private nonterminalId =
    | NONTERM_Macros
    | NONTERM_Rules
    | NONTERM__startspec
    | NONTERM_args
    | NONTERM_charset
    | NONTERM_clause
    | NONTERM_clauses
    | NONTERM_codeopt
    | NONTERM_macro
    | NONTERM_optbar
    | NONTERM_regexp
    | NONTERM_rule
    | NONTERM_spec

/// Maps tokens to integer indexes.
let private tagOfToken = function
    | AND -> 0
    | BAR -> 1
    | CHAR _ -> 2
    | CODE _ -> 3
    | DASH -> 4
    | DOT -> 5
    | EOF -> 6
    | EQUALS -> 7
    | HAT -> 8
    | IDENT _ -> 9
    | LBRACK -> 10
    | LET -> 11
    | LPAREN -> 12
    | PARSE -> 13
    | PLUS -> 14
    | QMARK -> 15
    | RBRACK -> 16
    | RPAREN -> 17
    | RULE -> 18
    | STAR -> 19
    | STRING _ -> 20
    | UNDERSCORE -> 21
    | UNICODE_CATEGORY _ -> 22

/// Maps integer indices to symbolic token ids.
let private tokenTagToTokenId = function
    | 0 -> TOKEN_AND
    | 1 -> TOKEN_BAR
    | 2 -> TOKEN_CHAR
    | 3 -> TOKEN_CODE
    | 4 -> TOKEN_DASH
    | 5 -> TOKEN_DOT
    | 6 -> TOKEN_EOF
    | 7 -> TOKEN_EQUALS
    | 8 -> TOKEN_HAT
    | 9 -> TOKEN_IDENT
    | 10 -> TOKEN_LBRACK
    | 11 -> TOKEN_LET
    | 12 -> TOKEN_LPAREN
    | 13 -> TOKEN_PARSE
    | 14 -> TOKEN_PLUS
    | 15 -> TOKEN_QMARK
    | 16 -> TOKEN_RBRACK
    | 17 -> TOKEN_RPAREN
    | 18 -> TOKEN_RULE
    | 19 -> TOKEN_STAR
    | 20 -> TOKEN_STRING
    | 21 -> TOKEN_UNDERSCORE
    | 22 -> TOKEN_UNICODE_CATEGORY
    | 24 -> TOKEN_end_of_input
    | 23 -> TOKEN_error
    | tokenIdx ->
        failwithf "tokenTagToTokenId: Invalid token. (Tag = %i)" tokenIdx

/// Maps production indexes returned in syntax errors to strings representing
/// the non-terminal that would be produced by that production.
let private prodIdxToNonTerminal = function
    | 0 -> NONTERM__startspec
    | 1 -> NONTERM_Macros
    | 2 -> NONTERM_Macros
    | 3 -> NONTERM_Rules
    | 4 -> NONTERM_Rules
    | 5 -> NONTERM_args
    | 6 -> NONTERM_args
    | 7 -> NONTERM_charset
    | 8 -> NONTERM_charset
    | 9 -> NONTERM_charset
    | 10 -> NONTERM_clause
    | 11 -> NONTERM_clauses
    | 12 -> NONTERM_clauses
    | 13 -> NONTERM_codeopt
    | 14 -> NONTERM_codeopt
    | 15 -> NONTERM_macro
    | 16 -> NONTERM_optbar
    | 17 -> NONTERM_optbar
    | 18 -> NONTERM_regexp
    | 19 -> NONTERM_regexp
    | 20 -> NONTERM_regexp
    | 21 -> NONTERM_regexp
    | 22 -> NONTERM_regexp
    | 23 -> NONTERM_regexp
    | 24 -> NONTERM_regexp
    | 25 -> NONTERM_regexp
    | 26 -> NONTERM_regexp
    | 27 -> NONTERM_regexp
    | 28 -> NONTERM_regexp
    | 29 -> NONTERM_regexp
    | 30 -> NONTERM_regexp
    | 31 -> NONTERM_regexp
    | 32 -> NONTERM_rule
    | 33 -> NONTERM_spec
    | prodIdx ->
        failwithf "prodIdxToNonTerminal: Invalid production index. (Index = %i)" prodIdx

let [<Literal>] private _fsyacc_endOfInputTag = 24
let [<Literal>] private _fsyacc_tagOfErrorTerminal = 23

/// Gets the name of a token as a string.
let token_to_string = function
    | AND -> "AND"
    | BAR -> "BAR"
    | CHAR _ -> "CHAR"
    | CODE _ -> "CODE"
    | DASH -> "DASH"
    | DOT -> "DOT"
    | EOF -> "EOF"
    | EQUALS -> "EQUALS"
    | HAT -> "HAT"
    | IDENT _ -> "IDENT"
    | LBRACK -> "LBRACK"
    | LET -> "LET"
    | LPAREN -> "LPAREN"
    | PARSE -> "PARSE"
    | PLUS -> "PLUS"
    | QMARK -> "QMARK"
    | RBRACK -> "RBRACK"
    | RPAREN -> "RPAREN"
    | RULE -> "RULE"
    | STAR -> "STAR"
    | STRING _ -> "STRING"
    | UNDERSCORE -> "UNDERSCORE"
    | UNICODE_CATEGORY _ -> "UNICODE_CATEGORY"

/// Gets the data carried by a token as an object.
let private _fsyacc_dataOfToken = function
    | AND -> (null : System.Object)
    | BAR -> (null : System.Object)
    | CHAR _fsyacc_x -> box _fsyacc_x
    | CODE _fsyacc_x -> box _fsyacc_x
    | DASH -> (null : System.Object)
    | DOT -> (null : System.Object)
    | EOF -> (null : System.Object)
    | EQUALS -> (null : System.Object)
    | HAT -> (null : System.Object)
    | IDENT _fsyacc_x -> box _fsyacc_x
    | LBRACK -> (null : System.Object)
    | LET -> (null : System.Object)
    | LPAREN -> (null : System.Object)
    | PARSE -> (null : System.Object)
    | PLUS -> (null : System.Object)
    | QMARK -> (null : System.Object)
    | RBRACK -> (null : System.Object)
    | RPAREN -> (null : System.Object)
    | RULE -> (null : System.Object)
    | STAR -> (null : System.Object)
    | STRING _fsyacc_x -> box _fsyacc_x
    | UNDERSCORE -> (null : System.Object)
    | UNICODE_CATEGORY _fsyacc_x -> box _fsyacc_x

let private _fsyacc_gotos = [| 0us; 65535us; 2us; 65535us; 3us; 6us; 4us; 7us; 2us; 65535us; 9us; 13us; 23us; 36us; 2us; 65535us; 12us; 25us; 24us; 37us; 5us; 65535us; 21us; 33us; 33us; 41us; 34us; 43us; 41us; 41us; 43us; 41us; 2us; 65535us; 49us; 51us; 54us; 51us; 2us; 65535us; 49us; 52us; 54us; 55us; 2us; 65535us; 0us; 3us; 13us; 26us; 2us; 65535us; 3us; 4us; 4us; 4us; 1us; 65535us; 45us; 49us; 10us; 65535us; 10us; 14us; 14us; 27us; 22us; 35us; 27us; 27us; 31us; 39us; 35us; 27us; 39us; 27us; 49us; 50us; 50us; 27us; 54us; 50us; 2us; 65535us; 9us; 11us; 23us; 11us; 1us; 65535us; 0us; 1us; |]
let private _fsyacc_sparseGotoTableRowOffsets = [| 0us; 1us; 4us; 7us; 10us; 16us; 19us; 22us; 25us; 28us; 30us; 41us; 44us; |]
let private _fsyacc_stateToProdIdxsTableElements = [| 4us; 0us; 14us; 13us; 33us; 1us; 0us; 1us; 13us; 4us; 1us; 2us; 15us; 33us; 4us; 1us; 2us; 2us; 15us; 1us; 15us; 1us; 33us; 1us; 2us; 1us; 15us; 4us; 4us; 3us; 32us; 33us; 15us; 15us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 27us; 26us; 24us; 30us; 29us; 28us; 31us; 2us; 4us; 3us; 3us; 5us; 6us; 32us; 3us; 14us; 13us; 33us; 20us; 15us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 25us; 27us; 27us; 26us; 26us; 24us; 24us; 30us; 29us; 28us; 28us; 31us; 1us; 18us; 1us; 20us; 1us; 23us; 1us; 22us; 1us; 21us; 1us; 19us; 5us; 7us; 9us; 8us; 30us; 31us; 15us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 27us; 26us; 24us; 30us; 29us; 29us; 28us; 31us; 4us; 4us; 3us; 3us; 32us; 3us; 5us; 6us; 6us; 1us; 32us; 1us; 33us; 20us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 25us; 27us; 27us; 26us; 26us; 24us; 24us; 24us; 30us; 29us; 28us; 28us; 31us; 1us; 25us; 1us; 27us; 1us; 26us; 15us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 27us; 26us; 24us; 30us; 29us; 28us; 28us; 31us; 2us; 7us; 8us; 5us; 7us; 9us; 9us; 8us; 30us; 4us; 7us; 9us; 8us; 31us; 20us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 25us; 27us; 27us; 26us; 26us; 24us; 24us; 30us; 29us; 29us; 28us; 28us; 31us; 1us; 3us; 1us; 6us; 1us; 32us; 20us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 25us; 27us; 27us; 26us; 26us; 24us; 24us; 30us; 29us; 28us; 28us; 28us; 31us; 1us; 8us; 5us; 7us; 9us; 9us; 9us; 8us; 1us; 30us; 5us; 7us; 9us; 9us; 8us; 31us; 1us; 29us; 3us; 16us; 17us; 32us; 1us; 8us; 1us; 31us; 1us; 17us; 18us; 10us; 12us; 11us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 27us; 26us; 24us; 30us; 29us; 28us; 31us; 32us; 20us; 10us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 25us; 27us; 27us; 26us; 26us; 24us; 24us; 30us; 29us; 28us; 28us; 31us; 2us; 12us; 11us; 1us; 32us; 1us; 10us; 18us; 10us; 12us; 11us; 11us; 18us; 20us; 23us; 22us; 21us; 19us; 25us; 27us; 26us; 24us; 30us; 29us; 28us; 31us; 1us; 11us; |]
let private _fsyacc_stateToProdIdxsTableRowOffsets = [| 0us; 5us; 7us; 9us; 14us; 19us; 21us; 23us; 25us; 27us; 32us; 48us; 51us; 55us; 59us; 80us; 82us; 84us; 86us; 88us; 90us; 92us; 98us; 114us; 119us; 123us; 125us; 127us; 148us; 150us; 152us; 154us; 170us; 173us; 179us; 184us; 205us; 207us; 209us; 211us; 232us; 234us; 240us; 242us; 248us; 250us; 254us; 256us; 258us; 260us; 279us; 300us; 303us; 305us; 307us; 326us; |]
let [<Literal>] private _fsyacc_action_rows = 56
let private _fsyacc_actionTableElements = [| 2us; 16398us; 3us; 2us; 23us; 32768us; 1us; 32768us; 24us; 49152us; 1us; 16397us; 23us; 32768us; 2us; 16385us; 11us; 5us; 23us; 32768us; 2us; 16385us; 11us; 5us; 23us; 32768us; 1us; 32768us; 9us; 8us; 1us; 32768us; 18us; 9us; 1us; 16386us; 23us; 32768us; 1us; 32768us; 7us; 10us; 1us; 32768us; 9us; 12us; 8us; 32768us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 20us; 18us; 21us; 19us; 22us; 20us; 2us; 16388us; 0us; 23us; 23us; 32768us; 2us; 16389us; 9us; 24us; 23us; 32768us; 2us; 16398us; 3us; 2us; 23us; 32768us; 13us; 16399us; 1us; 31us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 14us; 28us; 15us; 29us; 19us; 30us; 20us; 18us; 21us; 19us; 22us; 20us; 23us; 32768us; 1us; 16402us; 23us; 32768us; 1us; 16404us; 23us; 32768us; 1us; 16407us; 23us; 32768us; 1us; 16406us; 23us; 32768us; 1us; 16405us; 23us; 32768us; 1us; 16403us; 23us; 32768us; 2us; 32768us; 2us; 32us; 8us; 34us; 8us; 32768us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 20us; 18us; 21us; 19us; 22us; 20us; 1us; 32768us; 9us; 12us; 2us; 16389us; 9us; 24us; 23us; 32768us; 1us; 32768us; 7us; 38us; 1us; 16417us; 23us; 32768us; 13us; 16408us; 1us; 31us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 14us; 28us; 15us; 29us; 19us; 30us; 20us; 18us; 21us; 19us; 22us; 20us; 23us; 32768us; 1us; 16409us; 23us; 32768us; 1us; 16411us; 23us; 32768us; 1us; 16410us; 23us; 32768us; 8us; 32768us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 20us; 18us; 21us; 19us; 22us; 20us; 2us; 16391us; 4us; 40us; 23us; 32768us; 2us; 32768us; 2us; 32us; 16us; 42us; 1us; 32768us; 2us; 32us; 13us; 32768us; 1us; 31us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 14us; 28us; 15us; 29us; 17us; 44us; 19us; 30us; 20us; 18us; 21us; 19us; 22us; 20us; 1us; 16387us; 23us; 32768us; 1us; 16390us; 23us; 32768us; 1us; 32768us; 13us; 45us; 12us; 16412us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 14us; 28us; 15us; 29us; 19us; 30us; 20us; 18us; 21us; 19us; 22us; 20us; 23us; 32768us; 1us; 32768us; 2us; 46us; 2us; 16393us; 2us; 32us; 23us; 32768us; 1us; 16414us; 23us; 32768us; 2us; 32768us; 2us; 32us; 16us; 47us; 1us; 16413us; 23us; 32768us; 2us; 16400us; 1us; 48us; 23us; 32768us; 1us; 16392us; 23us; 32768us; 1us; 16415us; 23us; 32768us; 1us; 16401us; 23us; 32768us; 8us; 32768us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 20us; 18us; 21us; 19us; 22us; 20us; 13us; 32768us; 1us; 31us; 2us; 15us; 3us; 53us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 14us; 28us; 15us; 29us; 19us; 30us; 20us; 18us; 21us; 19us; 22us; 20us; 2us; 16396us; 1us; 54us; 23us; 32768us; 1us; 16416us; 23us; 32768us; 1us; 16394us; 23us; 32768us; 8us; 32768us; 2us; 15us; 6us; 16us; 9us; 17us; 10us; 21us; 12us; 22us; 20us; 18us; 21us; 19us; 22us; 20us; 1us; 16395us; 23us; 32768us; |]
let private _fsyacc_actionTableRowOffsets = [| 0us; 3us; 5us; 7us; 10us; 13us; 15us; 17us; 19us; 21us; 23us; 32us; 35us; 38us; 41us; 55us; 57us; 59us; 61us; 63us; 65us; 67us; 70us; 79us; 81us; 84us; 86us; 88us; 102us; 104us; 106us; 108us; 117us; 120us; 123us; 125us; 139us; 141us; 143us; 145us; 158us; 160us; 163us; 165us; 168us; 170us; 173us; 175us; 177us; 179us; 188us; 202us; 205us; 207us; 209us; 218us; |]
let private _fsyacc_reductionSymbolCounts = [| 1us; 0us; 2us; 3us; 1us; 0us; 2us; 1us; 3us; 2us; 2us; 3us; 1us; 1us; 0us; 4us; 0us; 1us; 1us; 1us; 1us; 1us; 1us; 1us; 2us; 2us; 2us; 2us; 3us; 3us; 3us; 4us; 6us; 5us; |]
let private _fsyacc_productionToNonTerminalTable = [| 0us; 1us; 1us; 2us; 2us; 3us; 3us; 4us; 4us; 4us; 5us; 6us; 6us; 7us; 7us; 8us; 9us; 9us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 10us; 11us; 12us; |]
let private _fsyacc_immediateActions = [| 65535us; 49152us; 16397us; 65535us; 65535us; 65535us; 65535us; 16386us; 65535us; 65535us; 65535us; 65535us; 65535us; 65535us; 65535us; 16402us; 16404us; 16407us; 16406us; 16405us; 16403us; 65535us; 65535us; 65535us; 65535us; 65535us; 16417us; 65535us; 16409us; 16411us; 16410us; 65535us; 65535us; 65535us; 65535us; 65535us; 16387us; 16390us; 65535us; 65535us; 65535us; 65535us; 16414us; 65535us; 16413us; 65535us; 16392us; 16415us; 16401us; 65535us; 65535us; 65535us; 16416us; 16394us; 65535us; 16395us; |]
let private _fsyacc_reductions () = [|
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : Specification)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    raise (Microsoft.FSharp.Text.Parsing.Accept (Microsoft.FSharp.Core.Operators.box _1))
                )
            : '_startspec))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    [] 
                )
            : 'Macros))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'macro)) in
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'Macros)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    _1 :: _2 
                )
            : 'Macros))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'rule)) in
        let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : 'Rules)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    _1 :: _3 
                )
            : 'Rules))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'rule)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    [_1] 
                )
            : 'Rules))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    [] 
                )
            : 'args))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'args)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    _1 :: _2 
                )
            : 'args))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : char)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    CharSet.singleton _1 
                )
            : 'charset))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : char)) in
        let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : char)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    CharSet.ofRange _1 _3 
                )
            : 'charset))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'charset)) in
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'charset)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    CharSet.union _1 _2 
                )
            : 'charset))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : CodeFragment)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    { Pattern = _1; Action = _2; } 
                )
            : 'clause))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'clause)) in
        let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : 'clauses)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    _1 :: _3 
                )
            : 'clauses))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'clause)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    [_1] 
                )
            : 'clauses))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : CodeFragment)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    Some _1 
                )
            : 'codeopt))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    //"", (fst parseState.ResultRange)
                    None 
                )
            : 'codeopt))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in
        let _4 = (let data = parseState.GetInput(4) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    match _4 with
                    | Pattern pattern ->
                        let pos =
                            let rawStartPos, rawEndPos = parseState.ResultRange
                            let startPos = SourcePosition (uint32 rawStartPos.Line, uint32 rawStartPos.Column)
                            let endPos = SourcePosition (uint32 rawEndPos.Line, uint32 rawEndPos.Column)
                            Some (startPos, endPos)
                        ((pos, _2), pattern)
                    | EndOfFile ->
                        let msg = sprintf "End-of-file pattern in macro '%s'." _2
                        raise <| exn msg
                    
                )
            : 'macro))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                )
            : 'optbar))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                )
            : 'optbar))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : char)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    Pattern <| Character _1 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    Pattern <| UnicodeCategory _1 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    EndOfFile 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    Pattern Any 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    Pattern <| Pattern.literalString _1 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    Pattern <| Macro _1 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    match _1, _2 with
                    | Pattern pat1, Pattern pat2 ->
                        Pattern <| Concat (pat1, pat2)
                    | _ ->
                        raise <| exn "End-of-file marker in Concat pattern." 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    match _1 with
                    | Pattern pattern ->
                        Pattern <| OneOrMore pattern
                    | EndOfFile ->
                        raise <| exn "End-of-file marker in OneOrMore pattern." 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    match _1 with
                    | Pattern pattern ->
                        Pattern <| Star pattern
                    | EndOfFile ->
                        raise <| exn "End-of-file marker in Star pattern." 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    match _1 with
                    | Pattern pattern ->
                        Pattern <| Optional pattern
                    | EndOfFile ->
                        raise <| exn "End-of-file marker in Optional pattern." 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    match _1, _3 with
                    | Pattern pat1, Pattern pat2 ->
                        Pattern <| Or (pat1, pat2)
                    | _ ->
                        raise <| exn "End-of-file marker in Or pattern." 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'regexp)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    _2 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'charset)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    Pattern <| CharacterSet _2 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _3 = (let data = parseState.GetInput(3) in (Microsoft.FSharp.Core.Operators.unbox data : 'charset)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    Pattern <| Negate (CharacterSet _3) 
                )
            : 'regexp))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'args)) in
        let _5 = (let data = parseState.GetInput(5) in (Microsoft.FSharp.Core.Operators.unbox data : 'optbar)) in
        let _6 = (let data = parseState.GetInput(6) in (Microsoft.FSharp.Core.Operators.unbox data : 'clauses)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    let rule = {
                        Parameters = _2;
                        Clauses = _6; }
                    let pos =
                        let rawStartPos, rawEndPos = parseState.ResultRange
                        let startPos = SourcePosition (uint32 rawStartPos.Line, uint32 rawStartPos.Column)
                        let endPos = SourcePosition (uint32 rawEndPos.Line, uint32 rawEndPos.Column)
                        Some (startPos, endPos)
                    
                    ((pos, _1), rule) 
                )
            : 'rule))
    (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
        let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : 'codeopt)) in
        let _2 = (let data = parseState.GetInput(2) in (Microsoft.FSharp.Core.Operators.unbox data : 'Macros)) in
        let _4 = (let data = parseState.GetInput(4) in (Microsoft.FSharp.Core.Operators.unbox data : 'Rules)) in
        let _5 = (let data = parseState.GetInput(5) in (Microsoft.FSharp.Core.Operators.unbox data : 'codeopt)) in
        Microsoft.FSharp.Core.Operators.box
            (
                (
                    
                    {   Header = _1;
                        Footer = _5;
                        Macros = _2;
                        Rules = _4; } 
                )
            : Specification))
    |]

let tables () : Microsoft.FSharp.Text.Parsing.Tables<_> = {
    reductions = _fsyacc_reductions ();
    endOfInputTag = _fsyacc_endOfInputTag;
    tagOfToken = tagOfToken;
    dataOfToken = _fsyacc_dataOfToken;
    actionTableElements = _fsyacc_actionTableElements;
    actionTableRowOffsets = _fsyacc_actionTableRowOffsets;
    stateToProdIdxsTableElements = _fsyacc_stateToProdIdxsTableElements;
    stateToProdIdxsTableRowOffsets = _fsyacc_stateToProdIdxsTableRowOffsets;
    reductionSymbolCounts = _fsyacc_reductionSymbolCounts;
    immediateActions = _fsyacc_immediateActions;
    gotos = _fsyacc_gotos;
    sparseGotoTableRowOffsets = _fsyacc_sparseGotoTableRowOffsets;
    tagOfErrorTerminal = _fsyacc_tagOfErrorTerminal;
    parseError =
        (fun (ctxt : Microsoft.FSharp.Text.Parsing.ParseErrorContext<_>) ->
            match parse_error_rich with
            | Some f -> f ctxt
            | None -> parse_error ctxt.Message);
    numTerminals = 25;
    productionToNonTerminalTable = _fsyacc_productionToNonTerminalTable;
    }
    
let engine lexer lexbuf startState =
    (tables ()).Interpret(lexer, lexbuf, startState)

let spec lexer lexbuf : Specification =
    unbox ((tables ()).Interpret(lexer, lexbuf, 0))

